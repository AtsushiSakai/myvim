/** 
 * @file mRPCEmulator.cpp
 *
 * @brief 擬似RPC通信を実現するノード
 *        基本的なコンセプトは、USBCANで読み取ったデータと、
 *        仮想RPCで読み取ったデータすべてバッファに集め、
 *        それらをすべて仮想RPCとUSBCANに送信する。
 *
 * @author Atsushi Sakai
 */

#include "ros/ros.h"
#include <iostream>
#include "../../../Tools/mRPC.h"  //RPC通信用

#include "SubscribeLib.h"  //トピック受信用

//mRPC用カスタムメッセージ
#include "mRPCEmulator/mRPCFrame.h"
#include "mRPCEmulator/mRPCPacket.h"

using namespace std;

//=========Global Variable=======
string NODE_NAME="mRPCEmulator";

//Topic受信用
SubVirtualmRPC recDriveCANA;
SubVirtualmRPC recDriveCANB;

/**
 *  @brief CANEmulatorノードのメインクラス
 */
class Node{
  public:
    Node(){
      n_  = new ros::NodeHandle;//ノードハンドラ
    }
    ~Node(){
      delete n_;
    }

    /**
     *  @brief ノードのメインループ関数　
     **/
    void main(){
      SetPublisherAndSubscriber();
      ros::Rate loopRate=GetLoopRate();//実行周期取得

      //RPC通信オブジェクトの生成(CAN通信の初期化)
      mRPC canA("Ch1","500k");
      CANInitAndCheck(canA);
      mRPC canB("Ch2","500k");
      CANInitAndCheck(canB);

      while (ros::ok()){
        ShowNodeInfo();//ノードの状態表示

        //CANBusのエミュレート各バスごとに実行する
        stat_A_=EmulateCANBus(canA,pubCAN_A_,recDriveCANA);
        stat_B_=EmulateCANBus(canB,pubCAN_B_,recDriveCANB);

        Diagnosis();//通信診断

        ros::spinOnce();	//check for incoming message
        loopRate.sleep();
      }
    }

    /**
     *  @brief 通信のステータス用構造体
     **/
    struct ComStatus{
      int nBuf;     //バッファのフレーム数
      int nReal;    //RealCANのフレーム数
      int nVirtual; //VirtualCANのフレーム数
    };

  private:
    //=====メンバ変数=====
    ros::NodeHandle *n_;  //ノード管理+パラメータサーバ用用
    
    //Publisher
    ros::Publisher pubCAN_A_;//CANA側の仮想mRPCのpublisher
    ros::Publisher pubCAN_B_;//CANB側の仮想mRPCのpublisher

    //SubScriver
    ros::Subscriber subDriveRPC_CAN_A_;
    ros::Subscriber subDriveRPC_CAN_B_;

    ComStatus stat_A_; //CAN Aの通信ステータス
    ComStatus stat_B_; //CAN Bの通信ステータス
    
    //=====メンバ関数=====
    /**
     *  @brief ノードの状態を表示する関数
     */
    void ShowNodeInfo(void){
      ROS_INFO_STREAM_THROTTLE(1.0,NODE_NAME
                               <<" nBuf CANA:"<<stat_A_.nBuf
                               <<" nBuf CANB:"<<stat_A_.nBuf
                               <<" nReal CANA:"<<stat_A_.nReal
                               <<" nReal CANB:"<<stat_A_.nReal
                               <<" Drive NCANA:"<<recDriveCANA.GetNFrames()
                               <<" Drive NCANB:"<<recDriveCANB.GetNFrames());
    }

    /**
     *  @brief 仮想CANBusの処理を実施する関数 
     *  @return バッファのフレーム数
     */
    ComStatus EmulateCANBus(mRPC can, ros::Publisher pub, SubVirtualmRPC drive){

        SubVirtualmRPC buf;//データ送受信用バッファ
        ComStatus stat;    //ステータス情報用変数

        //リアルCAN受信し、そのデータをバッファに格納
        stat.nReal=ReadRealCAN(can,buf);

        //各コントローラの仮想CANのデータをバッファに追加
        ReadVirtualCAN(drive,buf);//Driveコン

        //リアルmRPCの送信
        SendRealmRPC(can,buf);

        //仮想mRPCの送信
        SendVirtualmRPC(pub,buf);

        //バッファのフレーム数数の取得
        stat.nBuf=buf.GetNFrames();

        return stat;
    }
    
    /**
     *  @brief 仮想mRPCにデータを送信(Publish)する関数
     **/
    void SendVirtualmRPC(ros::Publisher &pub,const SubVirtualmRPC &buf){
      mRPCEmulator::mRPCPacket pkt;
      pkt.header.stamp=ros::Time::now();//時間の更新
      pkt.packet=buf.pkt.packet;//データをコピー
      pub.publish(pkt);//トピック送信
    }

    /**
     *  @brief VirtualRPCのパケットをbufに追加する関数
     */
    void ReadVirtualCAN(const SubVirtualmRPC &rec,SubVirtualmRPC &buf){
      int nPkt=rec.GetNFrames();//フレーム数
      //バッファの末尾にデータを追加
      for(int ifr=0;ifr<nPkt;ifr++){
        buf.pkt.packet.push_back(rec.pkt.packet[ifr]);
      }
    }

    /**
     * @brief 仮想CANのデータを実際のCAN busに送信する関数
     */
    void SendRealmRPC(mRPC &can, SubVirtualmRPC &rec){

      int nPkt=rec.GetNFrames();//フレーム数

      //受信したフレームをUSBCANで送信
      for(int ifr=0;ifr<nPkt;ifr++){
        mRPC::RPCData rpc;
        rpc.prior   =rec.pkt.packet[ifr].prior;
        rpc.src     =rec.pkt.packet[ifr].src;
        rpc.RPCNo   =rec.pkt.packet[ifr].RPCNo;
        rpc.dest    =rec.pkt.packet[ifr].dest;
        rpc.needAck =rec.pkt.packet[ifr].needAck;

        int ndata=rec.pkt.packet[ifr].data.size();
        rpc.data.resize(ndata);//事前確保
        for(int id=0;id<ndata;id++){
          rpc.data[id]=rec.pkt.packet[ifr].data[id];
        }

        can.SendRPC(rpc);//RPCの送信
      }
    }

    /**
     *  @brief USBCANからCANのデータを読み
     *          そのデータをバッファに格納する関数
     *  @return 受信したrpcの数
     */
    int ReadRealCAN(mRPC &can, SubVirtualmRPC &buf){
        //受信データの取得
        deque<mRPC::RPCData> recRPC=can.ReceiveRPC();
        int rpcSize=recRPC.size();

        //データの変換
        //mRPCクラスのデータから、VertialmRPCクラスのデータへ
        for(int irpc=0;irpc<rpcSize;irpc++){
          mRPCEmulator::mRPCFrame rpc;
          rpc.prior    = recRPC[irpc].prior;
          rpc.src      = recRPC[irpc].src;
          rpc.RPCNo    = recRPC[irpc].RPCNo;
          rpc.dest     = recRPC[irpc].dest;
          rpc.needAck  = recRPC[irpc].needAck;

          int ndata=recRPC[irpc].data.size();
          rpc.data.resize(ndata);//事前確保
          for(int id=0;id<ndata;id++){
            rpc.data[id]=recRPC[irpc].data[id];
          }

          buf.pkt.packet.push_back(rpc);//追加
        }

        return rpcSize;
    }

    /**
     *  @brief CANを初期化して、チェックする関数
     */
    void CANInitAndCheck(mRPC &can){
      if(can.GetInitStatus()){//ステータスチェック
        ROS_INFO_STREAM("CAN open success:");
      }
      else{
        ROS_FATAL_STREAM("CAN open fail:"<<can.GetErrorMsg());exit(2);//終了
      }
    }

    /**
     *  @brief ダイアグノシス
     */
    void Diagnosis(void){
      //===データ受信のダイアグノシス===
      //仮想CAN
      recDriveCANA.ReceiveDiagnosis("recDriveCANA");
      recDriveCANB.ReceiveDiagnosis("recDriveCANB");

      //Real CAN
      ReceiveRealCANDiagnosis("CANA",stat_A_);
      ReceiveRealCANDiagnosis("CANB",stat_B_);
    }

    /**
     * @brief Real CANの受信ダイアグノシス
     **/
    void ReceiveRealCANDiagnosis(const string &name,const ComStatus &stat){
      if(stat.nReal==0){
        ROS_INFO_STREAM("[ReceiveRealCANDiagnosis] Cannot receive Data From "<<name);
      }
    }

    /**
     *  @brief PublisherとSubscriberのトピック名と型を設定する関数
     */
    void SetPublisherAndSubscriber(){
      //=====Publisher=====
      pubCAN_A_ = n_->advertise<mRPCEmulator::mRPCPacket>(NODE_NAME+"/CANA", 50);
      pubCAN_B_ = n_->advertise<mRPCEmulator::mRPCPacket>(NODE_NAME+"/CANB", 50);

      //=====Subscriber=====
      //Driveコン
      subDriveRPC_CAN_A_=n_->subscribe("/Drive/RPC/CAN_A",100,
                            &SubVirtualmRPC::CallBack,&recDriveCANA);
      subDriveRPC_CAN_B_=n_->subscribe("/Drive/RPC/CAN_B",100,
                            &SubVirtualmRPC::CallBack,&recDriveCANB);

    }

    /**
     *  @brief ループの周期をパラメータサーバから取得する関数
     */
    ros::Rate GetLoopRate(){
      double loopRate=0.0;
      n_->getParam("/"+NODE_NAME+"/loop_rate",loopRate);
      ROS_INFO_STREAM("loop_rate:"<<loopRate<<"[Hz]");
      if(loopRate==0.0){
        ROS_FATAL_STREAM("[GetLoopRate] Cannot get param data");
        exit(0);//プログラム終了
      }
      ros::Rate loop_rate(loopRate);
      return loop_rate;
    }
};

int main(int argc, char **argv){
  ros::init(argc, argv, NODE_NAME);//ノード名を設定
  Node node;
  node.main();//メインループ
  return 0;
}

